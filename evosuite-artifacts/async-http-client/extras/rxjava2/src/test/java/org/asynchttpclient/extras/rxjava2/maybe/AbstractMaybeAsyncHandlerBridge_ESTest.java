/*
 * This file was automatically generated by EvoSuite
 * Fri Oct 07 16:09:11 GMT 2022
 */

package org.asynchttpclient.extras.rxjava2.maybe;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.UnpooledHeapByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelId;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.http.CombinedHttpHeaders;
import io.reactivex.MaybeEmitter;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.schedulers.ScheduledDirectTask;
import io.reactivex.internal.util.ArrayListSupplier;
import java.net.InetAddress;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLNonTransientConnectionException;
import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLTransactionRollbackException;
import javax.net.ssl.SSLSession;
import org.asynchttpclient.AsyncHandler;
import org.asynchttpclient.HttpResponseStatus;
import org.asynchttpclient.extras.rxjava2.maybe.MaybeAsyncHandlerBridge;
import org.asynchttpclient.extras.rxjava2.maybe.ProgressAsyncMaybeEmitterBridge;
import org.asynchttpclient.handler.ProgressAsyncHandler;
import org.asynchttpclient.netty.LazyResponseBodyPart;
import org.asynchttpclient.netty.request.NettyRequest;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.net.MockInetSocketAddress;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class AbstractMaybeAsyncHandlerBridge_ESTest extends AbstractMaybeAsyncHandlerBridge_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      MaybeEmitter<Integer> maybeEmitter0 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      AsyncHandler<Integer> asyncHandler0 = (AsyncHandler<Integer>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      doReturn((AsyncHandler.State) null).when(asyncHandler0).onStatusReceived(any(org.asynchttpclient.HttpResponseStatus.class));
      MaybeAsyncHandlerBridge<Integer> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Integer>(maybeEmitter0, asyncHandler0);
      maybeAsyncHandlerBridge0.onStatusReceived((HttpResponseStatus) null);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      MaybeEmitter<ScheduledDirectTask> maybeEmitter0 = (MaybeEmitter<ScheduledDirectTask>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      ProgressAsyncHandler<ScheduledDirectTask> progressAsyncHandler0 = (ProgressAsyncHandler<ScheduledDirectTask>) mock(ProgressAsyncHandler.class, new ViolatedAssumptionAnswer());
      ProgressAsyncMaybeEmitterBridge<ScheduledDirectTask> progressAsyncMaybeEmitterBridge0 = new ProgressAsyncMaybeEmitterBridge<ScheduledDirectTask>(maybeEmitter0, progressAsyncHandler0);
      ProgressAsyncHandler<? extends ScheduledDirectTask> progressAsyncHandler1 = progressAsyncMaybeEmitterBridge0.delegate();
      MaybeEmitter<Disposable> maybeEmitter1 = (MaybeEmitter<Disposable>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      ProgressAsyncMaybeEmitterBridge<Disposable> progressAsyncMaybeEmitterBridge1 = new ProgressAsyncMaybeEmitterBridge<Disposable>(maybeEmitter1, progressAsyncHandler1);
      AsyncHandler.State asyncHandler_State0 = progressAsyncMaybeEmitterBridge1.disposed();
      assertEquals(AsyncHandler.State.ABORT, asyncHandler_State0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      MaybeEmitter<ArrayListSupplier> maybeEmitter0 = (MaybeEmitter<ArrayListSupplier>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      ProgressAsyncHandler<ArrayListSupplier> progressAsyncHandler0 = (ProgressAsyncHandler<ArrayListSupplier>) mock(ProgressAsyncHandler.class, new ViolatedAssumptionAnswer());
      ProgressAsyncMaybeEmitterBridge<ArrayListSupplier> progressAsyncMaybeEmitterBridge0 = new ProgressAsyncMaybeEmitterBridge<ArrayListSupplier>(maybeEmitter0, progressAsyncHandler0);
      // Undeclared exception!
      try { 
        progressAsyncMaybeEmitterBridge0.onThrowable((Throwable) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.asynchttpclient.extras.rxjava2.maybe.AbstractMaybeAsyncHandlerBridge", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      NettyRequest nettyRequest0 = mock(NettyRequest.class, new ViolatedAssumptionAnswer());
      maybeAsyncHandlerBridge0.onRequestSend(nettyRequest0);
      MaybeEmitter<Integer> maybeEmitter1 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter1).isDisposed();
      AsyncHandler<Integer> asyncHandler1 = (AsyncHandler<Integer>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<Integer> maybeAsyncHandlerBridge1 = new MaybeAsyncHandlerBridge<Integer>(maybeEmitter1, asyncHandler1);
      NettyRequest nettyRequest1 = mock(NettyRequest.class, new ViolatedAssumptionAnswer());
      maybeAsyncHandlerBridge1.onRequestSend(nettyRequest1);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      MaybeEmitter<Integer> maybeEmitter0 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<Integer> asyncHandler0 = (AsyncHandler<Integer>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<Integer> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Integer>(maybeEmitter0, asyncHandler0);
      maybeAsyncHandlerBridge0.onTlsHandshakeAttempt();
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException();
      SQLIntegrityConstraintViolationException sQLIntegrityConstraintViolationException0 = new SQLIntegrityConstraintViolationException(sQLSyntaxErrorException0);
      maybeAsyncHandlerBridge0.onThrowable(sQLIntegrityConstraintViolationException0);
      assertEquals(0, sQLIntegrityConstraintViolationException0.getErrorCode());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      MaybeEmitter<Void> maybeEmitter0 = (MaybeEmitter<Void>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      MaybeEmitter<Integer> maybeEmitter1 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter1).isDisposed();
      ProgressAsyncHandler<Integer> progressAsyncHandler0 = (ProgressAsyncHandler<Integer>) mock(ProgressAsyncHandler.class, new ViolatedAssumptionAnswer());
      doReturn((Integer) null).when(progressAsyncHandler0).onCompleted();
      ProgressAsyncMaybeEmitterBridge<Integer> progressAsyncMaybeEmitterBridge0 = new ProgressAsyncMaybeEmitterBridge<Integer>(maybeEmitter1, progressAsyncHandler0);
      MaybeAsyncHandlerBridge<Void> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Void>(maybeEmitter0, progressAsyncMaybeEmitterBridge0);
      maybeAsyncHandlerBridge0.onCompleted();
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      MaybeEmitter<Disposable> maybeEmitter0 = (MaybeEmitter<Disposable>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      AsyncHandler<Disposable> asyncHandler0 = (AsyncHandler<Disposable>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<Disposable> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Disposable>(maybeEmitter0, asyncHandler0);
      SQLNonTransientException sQLNonTransientException0 = new SQLNonTransientException();
      SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException(sQLNonTransientException0);
      maybeAsyncHandlerBridge0.onThrowable(sQLTransactionRollbackException0);
      assertEquals("java.sql.SQLTransactionRollbackException: java.sql.SQLNonTransientException", sQLTransactionRollbackException0.toString());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      ProgressAsyncHandler<ChannelDuplexHandler> progressAsyncHandler0 = (ProgressAsyncHandler<ChannelDuplexHandler>) mock(ProgressAsyncHandler.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(progressAsyncHandler0).onCompleted();
      ProgressAsyncMaybeEmitterBridge<ChannelDuplexHandler> progressAsyncMaybeEmitterBridge0 = new ProgressAsyncMaybeEmitterBridge<ChannelDuplexHandler>(maybeEmitter0, progressAsyncHandler0);
      progressAsyncMaybeEmitterBridge0.onCompleted();
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      System.setCurrentTimeMillis((-3222L));
      MaybeEmitter<Disposable> maybeEmitter0 = (MaybeEmitter<Disposable>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      MaybeEmitter<Void> maybeEmitter1 = (MaybeEmitter<Void>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter1).isDisposed();
      MaybeAsyncHandlerBridge<Void> maybeAsyncHandlerBridge1 = new MaybeAsyncHandlerBridge<Void>(maybeEmitter1, maybeAsyncHandlerBridge0);
      CombinedHttpHeaders combinedHttpHeaders0 = new CombinedHttpHeaders(true);
      AsyncHandler.State asyncHandler_State0 = maybeAsyncHandlerBridge1.onHeadersReceived(combinedHttpHeaders0);
      assertEquals(AsyncHandler.State.ABORT, asyncHandler_State0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true, false, true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      NettyRequest nettyRequest0 = mock(NettyRequest.class, new ViolatedAssumptionAnswer());
      maybeAsyncHandlerBridge0.onRequestSend(nettyRequest0);
      maybeAsyncHandlerBridge0.onHostnameResolutionFailure("+KEkyep", (Throwable) null);
      AsyncHandler.State asyncHandler_State0 = maybeAsyncHandlerBridge0.onStatusReceived((HttpResponseStatus) null);
      assertEquals(AsyncHandler.State.ABORT, asyncHandler_State0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      MaybeEmitter<Integer> maybeEmitter0 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false, true, false).when(maybeEmitter0).isDisposed();
      Integer integer0 = new Integer(2);
      AsyncHandler.State asyncHandler_State0 = AsyncHandler.State.CONTINUE;
      AsyncHandler<Integer> asyncHandler0 = (AsyncHandler<Integer>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      doReturn(integer0).when(asyncHandler0).onCompleted();
      doReturn(asyncHandler_State0).when(asyncHandler0).onStatusReceived(any(org.asynchttpclient.HttpResponseStatus.class));
      MaybeAsyncHandlerBridge<Integer> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Integer>(maybeEmitter0, asyncHandler0);
      SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException("=]0clXOMYP", "=]0clXOMYP");
      maybeAsyncHandlerBridge0.onCompleted();
      maybeAsyncHandlerBridge0.onTlsHandshakeFailure(sQLNonTransientConnectionException0);
      AsyncHandler.State asyncHandler_State1 = maybeAsyncHandlerBridge0.onStatusReceived((HttpResponseStatus) null);
      assertEquals(AsyncHandler.State.CONTINUE, asyncHandler_State1);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true, false, true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      NettyRequest nettyRequest0 = mock(NettyRequest.class, new ViolatedAssumptionAnswer());
      maybeAsyncHandlerBridge0.onRequestSend(nettyRequest0);
      maybeAsyncHandlerBridge0.onHostnameResolutionFailure("+KEkyep", (Throwable) null);
      LazyResponseBodyPart lazyResponseBodyPart0 = new LazyResponseBodyPart((ByteBuf) null, true);
      AsyncHandler.State asyncHandler_State0 = maybeAsyncHandlerBridge0.onBodyPartReceived(lazyResponseBodyPart0);
      assertEquals(AsyncHandler.State.ABORT, asyncHandler_State0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true, false).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      doReturn((AsyncHandler.State) null).when(asyncHandler0).onBodyPartReceived(any(org.asynchttpclient.HttpResponseBodyPart.class));
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      maybeAsyncHandlerBridge0.onHostnameResolutionFailure("+KEkyep", (Throwable) null);
      LazyResponseBodyPart lazyResponseBodyPart0 = new LazyResponseBodyPart((ByteBuf) null, true);
      maybeAsyncHandlerBridge0.onBodyPartReceived(lazyResponseBodyPart0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      SSLSession sSLSession0 = mock(SSLSession.class, new ViolatedAssumptionAnswer());
      maybeAsyncHandlerBridge0.onTlsHandshakeSuccess(sSLSession0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      MaybeEmitter<ChannelDuplexHandler> maybeEmitter0 = (MaybeEmitter<ChannelDuplexHandler>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<ChannelDuplexHandler> asyncHandler0 = (AsyncHandler<ChannelDuplexHandler>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<ChannelDuplexHandler> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<ChannelDuplexHandler>(maybeEmitter0, asyncHandler0);
      MaybeEmitter<Void> maybeEmitter1 = (MaybeEmitter<Void>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter1).isDisposed();
      MaybeAsyncHandlerBridge<Void> maybeAsyncHandlerBridge1 = new MaybeAsyncHandlerBridge<Void>(maybeEmitter1, maybeAsyncHandlerBridge0);
      maybeAsyncHandlerBridge1.onConnectionPoolAttempt();
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      MaybeEmitter<UnpooledHeapByteBuf> maybeEmitter0 = (MaybeEmitter<UnpooledHeapByteBuf>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      AsyncHandler<UnpooledHeapByteBuf> asyncHandler0 = (AsyncHandler<UnpooledHeapByteBuf>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<UnpooledHeapByteBuf> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<UnpooledHeapByteBuf>(maybeEmitter0, asyncHandler0);
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress(" ", 0);
      maybeAsyncHandlerBridge0.onTcpConnectAttempt(mockInetSocketAddress0);
      assertEquals(0, mockInetSocketAddress0.getPort());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      MaybeEmitter<Object> maybeEmitter0 = (MaybeEmitter<Object>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      AsyncHandler<Integer> asyncHandler0 = (AsyncHandler<Integer>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<Object> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<Object>(maybeEmitter0, asyncHandler0);
      maybeAsyncHandlerBridge0.onConnectionOffer((Channel) null);
      maybeAsyncHandlerBridge0.onCompleted();
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      MaybeEmitter<UnpooledHeapByteBuf> maybeEmitter0 = (MaybeEmitter<UnpooledHeapByteBuf>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      AsyncHandler<UnpooledHeapByteBuf> asyncHandler0 = (AsyncHandler<UnpooledHeapByteBuf>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<UnpooledHeapByteBuf> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<UnpooledHeapByteBuf>(maybeEmitter0, asyncHandler0);
      EmbeddedChannel embeddedChannel0 = new EmbeddedChannel((ChannelId) null);
      maybeAsyncHandlerBridge0.onConnectionPooled(embeddedChannel0);
      assertTrue(embeddedChannel0.isWritable());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      MaybeEmitter<Integer> maybeEmitter0 = (MaybeEmitter<Integer>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(maybeEmitter0).isDisposed();
      ProgressAsyncHandler<Integer> progressAsyncHandler0 = (ProgressAsyncHandler<Integer>) mock(ProgressAsyncHandler.class, new ViolatedAssumptionAnswer());
      ProgressAsyncMaybeEmitterBridge<Integer> progressAsyncMaybeEmitterBridge0 = new ProgressAsyncMaybeEmitterBridge<Integer>(maybeEmitter0, progressAsyncHandler0);
      MockInetSocketAddress mockInetSocketAddress0 = new MockInetSocketAddress((InetAddress) null, 17);
      progressAsyncMaybeEmitterBridge0.onTcpConnectSuccess(mockInetSocketAddress0, (Channel) null);
      assertEquals("/192.168.1.42:17", mockInetSocketAddress0.toString());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      MaybeEmitter<UnpooledHeapByteBuf> maybeEmitter0 = (MaybeEmitter<UnpooledHeapByteBuf>) mock(MaybeEmitter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(maybeEmitter0).isDisposed();
      AsyncHandler<UnpooledHeapByteBuf> asyncHandler0 = (AsyncHandler<UnpooledHeapByteBuf>) mock(AsyncHandler.class, new ViolatedAssumptionAnswer());
      MaybeAsyncHandlerBridge<UnpooledHeapByteBuf> maybeAsyncHandlerBridge0 = new MaybeAsyncHandlerBridge<UnpooledHeapByteBuf>(maybeEmitter0, asyncHandler0);
      maybeAsyncHandlerBridge0.onHostnameResolutionAttempt("");
  }
}
