/*
 * This file was automatically generated by EvoSuite
 * Tue Oct 11 01:56:57 GMT 2022
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.InputStream;
import java.lang.ref.PhantomReference;
import java.lang.ref.WeakReference;
import java.util.function.BiFunction;
import org.apache.commons.collections4.map.AbstractHashedMap;
import org.apache.commons.collections4.map.AbstractReferenceMap;
import org.apache.commons.collections4.map.ReferenceIdentityMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class ReferenceIdentityMap_ESTest extends ReferenceIdentityMap_ESTest_scaffolding {

 @Test(timeout = 4000)
  public void test0()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<InputStream, String> referenceIdentityMap0 = new ReferenceIdentityMap<InputStream, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      int int0 = AbstractHashedMap.MAXIMUM_CAPACITY;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength3 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<String, String> referenceIdentityMap1 = new ReferenceIdentityMap<String, String>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength3, true);
      ReferenceIdentityMap<Integer, InputStream> referenceIdentityMap2 = new ReferenceIdentityMap<Integer, InputStream>();
      referenceIdentityMap2.get(referenceIdentityMap0);
      referenceIdentityMap1.isEqualValue((Object) null, abstractReferenceMap_ReferenceStrength2);
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength4 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<MockFileInputStream, Object> referenceIdentityMap3 = new ReferenceIdentityMap<MockFileInputStream, Object>(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength4, 1073741824, 1073741824);
  }
 @Test(timeout = 4000)
  public void test1()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<Integer, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<Integer, Integer>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 3618, 3440.3123F);
      ReferenceIdentityMap<Object, Integer> referenceIdentityMap1 = new ReferenceIdentityMap<Object, Integer>();
      referenceIdentityMap1.isEqualKey(abstractReferenceMap_ReferenceStrength0, referenceIdentityMap0);
      referenceIdentityMap1.isEqualValue(abstractReferenceMap_ReferenceStrength0, "null values not allowed");
      ReferenceIdentityMap<PhantomReference<String>, String> referenceIdentityMap2 = new ReferenceIdentityMap<PhantomReference<String>, String>();
      BiFunction<Object, Object, String> biFunction0 = (BiFunction<Object, Object, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      referenceIdentityMap2.replaceAll(biFunction0);
      referenceIdentityMap2.purgeBeforeRead();
      int int0 = AbstractHashedMap.MAXIMUM_CAPACITY;
      ReferenceIdentityMap<Object, PhantomReference<Object>> referenceIdentityMap3 = new ReferenceIdentityMap<Object, PhantomReference<Object>>();
      referenceIdentityMap3.isEqualValue(referenceIdentityMap0, referenceIdentityMap0);
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength3 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<Integer, WeakReference<Integer>> referenceIdentityMap4 = new ReferenceIdentityMap<Integer, WeakReference<Integer>>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength3, 1073741824, 1073741824, true);
  }
 @Test(timeout = 4000)
  public void test2()  throws Throwable  {
      ReferenceIdentityMap<PhantomReference<String>, MockFileInputStream> referenceIdentityMap0 = new ReferenceIdentityMap<PhantomReference<String>, MockFileInputStream>();
      ReferenceIdentityMap<InputStream, PhantomReference<Integer>> referenceIdentityMap1 = new ReferenceIdentityMap<InputStream, PhantomReference<Integer>>();
      referenceIdentityMap1.hash((Object) null);
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      int int0 = (-242);
      boolean boolean0 = false;
      ReferenceIdentityMap<InputStream, InputStream> referenceIdentityMap2 = null;
      try {
        referenceIdentityMap2 = new ReferenceIdentityMap<InputStream, InputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, (-242), (-242), false);
        fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }
}
